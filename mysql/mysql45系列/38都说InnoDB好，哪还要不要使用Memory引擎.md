## 38|都说InnoDB好，哪还要不要使用Memory引擎？

### 内存表的数据组织结构

innodb引擎的主键组织方式是b+树，表的数据就放在主键索引树上，主键索引上的值是有序存储的。

Memory引擎不同，它的数据和索引是分开的。主键是hash索引，索引上的key并不是有序的。

- InnoDB引擎把数据放在主键上，其他索引保存的是主键id。这种方式称为索引组织表；
- Memory引擎采用数据单独存放，索引上保存数据为止的数据组成请示，这种方式称为堆组织表；

典型不同：

1. InnoDB表总是有序的，内存表的数据就是按照写入顺序存放的；
2. 当数据文件有空洞时，innoDB在插入新数据的时候，为保证数据数据有序性，只能在固定的为止写入新值，而内存表找到空位就可以插入新值；
3. 数据为止发生变化时，InnoDB表只需要修改主键索引，而内存表需要修改所有索引；
4. InnoDB表用主键索引查询时需要走一次索引查找，用普通索引查询时候，需要走两次索引查找。而内存表没有这个区别，所有索引的地位是相同的；
5. InnoDB支持变长数据类型，不同记录的长度可能不同；内存表不支持Blob和Text字段，并且即使定义了varchar(N)，实际也当作CHAR(N)，因此内存表的每行数据相同。



### hash索引和B-索引

实际上内存表也支持B-索引。组织形式与B+树类似。

内存表的优势是速度快，其中一个原因就是支持hash索引，更重要的是，所有数据都保存在内存，内存读写总是比磁盘块。

但不建议上生产：

1. 锁粒度问题；
2. 数据持久化问题；

#### 内存表的锁

内存表不支持行锁，只支持表锁。

跟行锁比起来，表锁并发访问的支持不够好。

#### 数据持久性问题

重启数据库，内存会被清空；内存表在异常重启的情况下，主从同步大概率会出问题。

有同学说，额你存表执行速度块，其实可以这么分析：

1. 表更新量大，并发度是一个很重要的参考指标，InnoDB支持行锁，并发度比内存表好；
2. 能放到内存的数据量都不大，如果你考虑得是读性能，一个QPS很高且数据量不大得表，即使使用InnoDB，数据也是会缓存在BufferPool里面，InnoDB得读性能不会差。

一个场景例外：

用户临时表。数据量可控，不会耗费过多内存。

1. 临时表不会被其他线程访问，没有并发性问题；
2. 临时表重启后也是需要删除的，清空这个问题不存在；
3. 备库的临时表也不会影响主库的用户线程。



### 小结

- 内存表一般是hash索引，也可以B-索引
- InnoDB的索引是有序的，内存表一般是hash无序的
- 内存表有高并发问题，数据持久化问题
- 内存表适合做临时表

