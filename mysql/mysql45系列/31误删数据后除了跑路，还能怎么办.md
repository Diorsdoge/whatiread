## 31|误删数据后除了跑路，还能怎么办？

今天作者说要讨论一个沉重的话题：误删数据

传统的高可用是无法预防误删数据的，因为i主库的一个drop  table命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令；

分类：

1. 使用delete语句误删数据行；
2. 使用drop table 或者truncate table语句误删数据表；
3. 使用drop database 语句误删数据库；
4. 使用rm 命令误删整个MySQL实例；



### 误删行

可以使用Flashback工具通过闪回把数据回复回来；其原理是修改binlog内容，拿回数据库重放，这个方案需要确保binlog_format=row和binlog_row_image=FULL。比如insert就转换为delete，如果是delete就转换为insert，如果是update， 就对调update内容，当然事务的执行顺序是倒过来的。

不建议在主库执行这些操作，比较安全的做法是：恢复出一个备份，或者找一个备库作为临时库，在临时库上执行这些操作。然后使用临时库的数据恢复回主库。

也要做提前预防：

1. sql_safe_updates参数设置为on，如果没有写where条件，或者where条件中没有索引字段，就会报错；
2. 代码上线前，必须经过SQL审计；

drop table / truncate table / drop database 删除的数据，就不能通过flashback来恢复了。因为执行这三个命令时，记录的binlog还是statement格式。binlog里面只有一个truncate / drop 数据，这些是恢复不出数据的。



### 误删库/表

定期全量备份，事实备份binlog；

假如中午有人12点删除了一个库：

1. 取最近一次全量备份；
2. 恢复临时库；
3. 取出当天0点之后备份日志；
4. 除了误删除数据的语句外，全部在临时库中重放；

这种方式不够快：

一种加速方法：用备份会付出临时实例之后，将这个临时实例设置成线上备库的从库；在start slave前，先 通过执行 change replication filter replicate_do_table=（tbl_name）命令，让临时库只同步误操作的表；

核心是：备份策略

另一种加速方法：延迟复制备库

如果库特别大，可以考虑搭建延迟复制备库，即：主动要求备库延迟是主库的N秒，change master to master_delay=N进行控制；



### 预防删库/表的方法

第一条建议：账号分离，比如：

- 只给研发同学开放DML权限，不给truncate / drop权限。
- 即使DBA平时也只用只读账号；

第二条建议：指定操作规范。

- 删除之前，对表做改名操作，观察一段时间再删；
- 改表名的时候要加后缀，标识这时备份表；



### rm 删除数据

主库rm了，且到备库，使用备库恢复主库；

备库rm了，使用主库，重新搭建备库；

核心：不能全军覆没



### 小结

- 误删行，使用flushback
- 误删表，数据库，使用备份加binlog
- 还是要预误删
- 恢复最好在备库或者临时库
- rm删除数据反而比较稳，但切忌全部rm了，那是真的有仇

