## 39|自增主键为什么不是连续的？

之前提到过，自增主键由于自增主键可以让主键索引尽量保持递增顺序插入，避免了也分裂，索引更紧凑。

自增主键不饿能保证连续性。

```mysql
create table t (
	id int not null auto_increment,
    c int default null,
    d int default null,
    primary key id,
    unique key c(c)
)engine=innodb;
```

### 自增值保存在哪儿

不同的引擎对于子增值的保存策略不同：

- MyISAM引擎的自增值保存在数据文件中；
- InnoDB的自增值，其实是保存在内存里，并且到了MySQL8.0版本后，才有了自增值持久化的能力，具体情况：
  - 5.7及以前版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会取找自增值最大值max(id)，然后将max(id)+1作为这个表的当前自增值；
  - 8.0，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。

### 自增值的修改机制

设置为auto_increment：

1. 如果插入数据时id字段指定为0，null或者未指定值，那么就把这个表当前auto_increment值填到自增字段；
2. 如果插入语句id制定了具体的值，就直接使用语句里指定的值；加入插入的值是X，当前自增值Y
   - 如果X<Y，这个表自增值不变；
   - 否则，就需要把当前自增值修改为新的自增值；新的自增值从auto_increament_offset开始，以auto_increment_increment为步长，持续叠加，直到找到第一个大于X的值作为新得自增值。

### 自增值的修改时机

- 唯一键冲突是导致自增主键id不连续的第一种原因。
- 事务回滚也会产生类似的现象，这时第二个原因。

MySQL为了提升性能，自增值不能回退：

为了避免两个事务申请到相同的自增id，肯定要加锁，然后顺序申请：

1. 假设事务A申请到了id=2，事务B申请到了id=3，那么这时候表的自增值是4；
2. 事务B提交了，但事务A出现唯一键冲突；
3. 如果允许事务A把自增id回滚，也就是把表t的当前自增值改回2，那么就会出现：表里面已经有id=3的行，而当前的自增id值是2；
4. 接下来，继续执行其他事务申请自增值2，再申请到3，插入会冲突；

为了解决主键冲突，两种办法：

1. 每次申请id前，判断表里面是否已经存在这个id，成本很高；
2. 把自增id的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能申请自增id，系统并发能力大大下降；

这两种方法都会导致性能问题，所以只保证了自增id是递增的，但不保证是连续的。

### 自增锁优化

对于批量插入数据的语句，MySQL有一个批量申请自增id的策略：

1. 第一次申请自增id，会被分配1个；
2. 1个用完后，这个语句第二次申请自增id，会分配2个；
3. 2个用完后，第三次申请会分配4个；
4. 依次类推，每次申请时上一次的两倍。

最后依次申请，很大程度上最后几个就被浪费了。

这是主键id出现自增id不连续的第三种原因。



### 小结

- MyISAM 自增值写在数据文件上；InnoDB 5.7及以前不持久化，根据表最大的max(id)来恢复，8.0之后持久化到redo log；
- 自增值的修改机制，0，null，不写，默认为按之前+1；否则，重新计算；
- 事务回滚，自增值不会回滚，导致之间不连续；
- 唯一键冲突，会导致主键不连续；
- 依次申请多个自增值，算法，导致主键不连续；