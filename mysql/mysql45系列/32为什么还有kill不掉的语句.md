## 32|为什么还有kill不掉的语句？

> MySQL中有两个kill命令：kill query + 线程id，表示终止这个线程中正在执行的语句；一个是 kill connection + 线程id，表示断开这个线程的连接，如果这个线程有语句正在执行，要先停止正在执行的语句；



### 收到kill以后，线程做什么？

当一个表做增删改查操作时，回在表上加MDL读锁。kill 并不是马上停止的意思，而实告诉执行线程，这条语句已经不需要继续执行了，可以开始执行停止的逻辑了。

实现上，kill query thread_id_B时，MySQL处理kill命令的线程做了两件事：

1. 把session B的运行状态字改成THD::KILL_QUERY(将变量killed赋值为THD::KILL_QUERY)
2. 给session B的执行线程发一个信号；

三层意思：

1. 一个语句执行过程中有多处埋点，这些埋点的地方判断线程状态，如果发现线程状态时THD::KILL_QUERY，才开始进入语句终止逻辑；
2. 如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到埋点处；
3. 语句从开始进入终止逻辑，到终止逻辑完成，是有一个过程的；

kill无效的第一类情况：线程没有执行到判断线程状态的逻辑；IO压力过大，读写IO的函数一直无法返回，导致不能及时判断线程的状态；并发线程过大，线程阻塞；

另一种情况；终止逻辑耗时较长。这时候show processlist 结果上看也是killed状态，需要等到终止逻辑完成：

1. 超大事务被kill。
2. 大查询回滚；
3. DDL命令到最后阶段，如果被kill，需要删除中间过程的临时文件。

Ctrl+C命令，并不能直接终止线程。其实客户端的操作只能操作到客户端的线程，客户端和服务端只能通过网络交互，是不可能直接操作服务端线程的。实际上Ctrl+C，是MySQL客户端另外启动一个连接，然后发送一个kill query命令。

### 另外关于客户端的两个误解

第一个误解：如果库里面的表特别多，连接就很慢。实际上，每个客户端与服务端建立连接的时候，需要做的事情是TCP握手，用户校验，获取权限。这几个操作都与库里面的表个数无关。只是当使用默认参数连接的时候，MySQL客户端会提供一个本地库名和表名补全功能，为了实现这个功能，客户端在连接成功后会：

1. show databases；
2. 切到DB1，show tables；
3. 把这两个命令的结果用于构建一个本地的哈希表。

这里面最花时间的实际上是构建这个hash表。

所以我们感知到的过程慢，并不是服务器慢，而实客户端慢。

加-A，关掉这个自动补全的参数；

或者-q 参数，也可以跳过这个阶段；但是-quick是一个更容易引起误会的参数，也是关于客户端常见的一个误解。

MySQL客户端发送请求后，接受服务端返回结果的方式有两种：

1. 本地缓存，本地把结果存起来；默认
2. 读一个处理一个； 加 -quick

采用第二种方式，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。

-quick 三个效果：

1. 跳过表明自动补全功能；
2. 默认方式需要申请本地内存来缓存查询结果，如果查询结果过大，会耗费较多得本地内存，可能影响到本地机器得性能；
3. 不会把执行命令记录到本地得命令历史文件。

-quick 参数得意思，实际上是让客户端变得更快。



### 小结

- 哪些kill不掉。线程没有执行到判断线程状态的逻辑；终止逻辑太慢；
- kill 之后实际上是发送信号，修改语句的运行状态；
- 表特别多，引起建立连接慢，实际上是客户端的问题，是开叻自动补全。
- kill connection可以只写kill