## 14|count(*)这么慢，我该怎么办？

> 这里作者想要聊count(*)语句是怎样实现的？



### count(*) 的实现方式

不同的引擎，count(*)的实现方式不同：

- MyISAM引擎把表的总行数存在了磁盘上，执行之后直接返回，效率很高；
- InnoDB，需要把数据一行一行从引擎里面读出来，让后累计计数。

如果加了where条件，MyISAM有不能返回这么快。

使用InnoDB引擎，就是当记录数越来越多的时候，计算一个表的总行数会越来越慢的原因。

为啥InnoDB不像MyISAM一样把数字存起来？主要是由于MVCC的原因，得到的数据多个事务可能是不一致的。

当然，在MySQL执行中还是做了优化的，主键索引树的叶子节点是数据，普通索引树的叶子节点是主键值。所以普通索引树比主键索引树小得多，MySQL优化器会找到最小得那棵树来遍历。在保证逻辑正确得前提下，尽量减少扫描的数据量，是数据库系统涉及得通用法则之一。

show table status得到的table_raws是一个采样估算的值，不能直接使用。

优化的基本思路：自己找个地方，把操作记录表的行数存起来。



### 用缓存系统保存计数

用redis来存，比如插入一行，计数+1，删除一行，计数-1。但，缓存系统可能会丢失更新：持久化，异常重启等场景；

针对不同的情况，使用不同的策略，比如重启之后再执行一次count(*)写入。



### 在数据库保存计数

使用事务的方式来查询，把存count(*)的表也加入到MVCC中，这样保证逻辑上是一致的。



### 不同的count用法

分析count(*), count(id), count(1),count(字段):

分析性能差别的时候的几个原则：

1. server层要什么就给什么；
2. InnoDB只给必要的值；
3. 现在的优化器只优化了count(*)的语义为“取行数”，其他“显而易见”的优化并没有做。

- 对于count(id)，InnoDB引擎遍历整张表，把每一行的id值都取出来返回给server层。server层拿到整行数据，判断是不可能是空的，按行累加。
- 对于count(1)来说，innoDB遍历整张表，但不取值。server层对于返回的每一行，放一个数字1进去，判断不可能是空的，按行累加。

单看这两个用法的差别，count(1)执行得比count(id)快。

对于count(字段)来说：

1. 字段是not null：逐行取出，判断不能为null，按行累加；
2. 允许为null：判断到有可能是null的，要把值取出来，在判断以下，不为null，按行累加。

符合原则1。

count(*)是例外，并不会把全部字段取出来，不取值。

结论：count(字段)<count(id)<count(1)≈count(*)

建议count(*)



### 小结

- MyISAM和InnoDB 对于count星是不一样的；
- 想要快的基本思路：把count(*)存起来， 使用缓存或者DB存起来；
- count(字段)<count(id)<count(1)≈count(*)







