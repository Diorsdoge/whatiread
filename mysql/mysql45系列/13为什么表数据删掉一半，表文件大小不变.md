## 13|为什么表数据删掉一半，表文件大小不变？

这里一张主要聊数据库表的空间回收。

一个InnoDB表包含两部分：定义表结构和数据。在MySQL8.0以前表结构存在以.frm为后缀文件里。8.0以后允许把表结构定义放在数据表中了。



### 参数 innodb_file_per_table

表数据可以共享在表空间里，也可以是单独的文件。这个行为由参数innodb_file_per_table控制。

1. OFF。表示数据放在系统共享表空间；
2. ON。表示每个InnoDB表数据文件存储在一个.ibd为后缀的文件中。

设为ON的时候，drop table会直接删掉这个文件，而OFF会删除共享表空间的数据，即便表删掉了，空间也不会立刻回收。（5.60之后默认为ON）



### 删数据的流程

![B+](D:\developer\whatidread\mysql\mysql45系列\b+树索引示意图.png)

假设要删除R4这个记录，InnoDB引擎会把R4这个记录标记为已删除。如果以后插入300-900之间的记录，可能会复用这个位置，但是文件大小不会变小。

如果删除整个页上所有的记录，那么整个页也可以被复用。但是跟记录的复用是不同得，它所有得位置都可以复用。如果delete命令把整个表得数据都删除了，结果就是，所有得数据页都会被标记为可复用，但文件大小不会改变。

这些可以复用而没有被使用得空间，看起来就像是“空洞”。

实际上，插入数据也会造成“空洞”。

如果数据是按照索引顺序插入的，那么索引是紧凑的；但如果数据是随机插入的，就可能造成索引的数据页分裂。

比如上图中插入550，有可能由于Page A满了，导致Page A分裂，之后在（550， 600， 700）在新页，新旧页末尾就都会产生“空洞”。

另外，更新索引上的值，可以理解为删除一个旧值，插入一个新值，也可能为造成“空洞”。

经过大量增删查改的表，可能需要重建表来将“空洞”去掉。



### 重建表

可以使用 alter table A engine=InnoDB 命令来重建表，5.5 之前 过程差不多为：新建表B，将A中的数据一行行select过去，操作完成之后，在使用B来替换掉A，从效果上就起到了收缩表A空间的作用；时间花在了select上，且表A是不能更新数的，也就是说这个DDL不是online的。

MySQL5.6开始引入online DDL：

1. 建立临时文件，扫描A主键的所有数据页；
2. 用数据页中表A的记录生成B+树，存储到临时文件中；
3. 生成临时文件过程中，将所有A的操作记录在一个日志文件（row log，有点像raw 格式的binlog）中：将之后对A的操作视作“增量操作”；
4. 临时文件生成后，将日志文件的操作（”增量操作“）应用到临时文件中，；
5. 用临时文件替换掉A的数据文件；

这个方法都会扫描原表数据和构建临时文件，会消耗比较多的IO和CPU资源。（作者推荐使用开源的 gh-ost力来做）



### online 和 inplace

在非Online重建表的过程中，把A中的数据导出来存放的位置叫做tmp_table，是个临时表，由server层创建。

在Online重建表的过程中，数据表A重建出来的数据是放在tmp_file里面的，这个临时文件实在InnoDB内部创建出来的，整个DDL的过程都在InnoDB内部完成。对于server来说，没有把数据挪动到临时表，是一个“原地”操作，着就叫做“inplace”。

如果一个1tb的表，磁盘现在1.2tb，能不能做一个inplace的DDL？不能，因为tmp_file也是要占用临时空间的。

``` MYSQL
alter table t engine=innodb, ALGORITHM=inplace;  -- inplace方式
alter table t engine=innodb, ALGORITHM=copy;  -- copy方式
```

二者概括：

1. DDL过程如果是Online的，就一定是inplace的；
2. 反过来未必。比如MySQL添加全文索引和空间索引就是这种情况；（截止到MySQL8.0）

- analyze table t不是重建表，只是对表信息进行收集，这个过程加了MDL锁；
- optimize table t等于 recreate+analyze。



### 小结

- 正常会一个表一个数据文件；
- 删数据流程实际上是标记为可复用；整页的特点是删除没有限制，直接复用；不管增删改都可能造成“空洞”；
- 重建表可以解决“空洞”问题
- 5.6之后为online，online重要是中间多了一个记录对A操作的日志，会在临时问价完成后重放日志内容；
- inplace为引擎层；非online为server层；
- online一定是inplace；反之不一定；
- online的意思可以理解为：对表结构的DDL操作不影响操作表数据；inplace可以理解为，创建临时文件由引擎层完成。



问题：一个1tb表，重建表之后，发现空间不仅没变小，还大了一些，比如变成1.01tb了。这时为什么？

答：可能是这个表本身就没有“空洞”了，DDL期间刚好有DML在执行，这期间还会引入新的空洞。



附：重建表的时候，InnoDB不会把整个页占满，每个页溜了1/16给后续的更新用。





